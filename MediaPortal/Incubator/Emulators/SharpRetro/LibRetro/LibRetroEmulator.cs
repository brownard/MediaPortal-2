using SharpRetro.Controller;
using SharpRetro.RetroGL;
using SharpRetro.Utils;
using SharpRetro.Video;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace SharpRetro.LibRetro
{
  public delegate void LogDelegate(LibRetroCore.RETRO_LOG_LEVEL level, string message);

  /// <summary>
  /// Implements the LibRetro API, enabling the loading and running of LibRetro cores
  /// </summary>
  public unsafe class LibRetroEmulator : IDisposable
  {
    #region LibRetro Callbacks
    LibRetroCore.retro_environment_t retro_environment_cb;
    LibRetroCore.retro_video_refresh_t retro_video_refresh_cb;
    LibRetroCore.retro_audio_sample_t retro_audio_sample_cb;
    LibRetroCore.retro_audio_sample_batch_t retro_audio_sample_batch_cb;
    LibRetroCore.retro_input_poll_t retro_input_poll_cb;
    LibRetroCore.retro_input_state_t retro_input_state_cb;
    LibRetroCore.retro_log_printf_t retro_log_printf_cb;
    LibRetroCore.retro_perf_callback retro_perf_callback = new LibRetroCore.retro_perf_callback();
    LibRetroCore.retro_rumble_interface retro_rumble_interface = new LibRetroCore.retro_rumble_interface();
    #endregion

    #region Protected Members
    protected const short TRUE_SHORT = 1;
    protected const short FALSE_SHORT = 0;

    protected string _corePath;
    protected LibRetroCore _retro;
    protected UnmanagedResourceHeap _unmanagedResources = new UnmanagedResourceHeap();
    protected LibRetroVariables _variables = new LibRetroVariables();
    protected LogDelegate _logDelegate;

    protected bool _firstRun = true;
    protected string _systemDirectory;
    protected string _saveDirectory;
    protected bool _canDupe = true;
    protected uint _performanceLevel;

    protected bool _supportsNoGame;
    protected IRetroGLContext _glContext;
    protected int[] _videoBuffer;
    protected int _maxVideoWidth;
    protected int _maxVideoHeight;
    protected AudioBuffer _audioBuffer;

    protected SystemInfo _systemInfo;
    protected VideoInfo _videoInfo;
    protected TimingInfo _timingInfo;
    protected LibRetroCore.RETRO_PIXEL_FORMAT _pixelFormat = LibRetroCore.RETRO_PIXEL_FORMAT.XRGB1555;

    protected IRetroController _retroController;
    protected IRetroPad _retroPad;
    protected IRetroAnalog _retroAnalog;
    protected IRetroKeyboard _retroKeyboard;
    protected IRetroPointer _retroPointer;
    protected IRetroRumble _retroRumble;
    #endregion

    #region Public Properties
    /// <summary>
    /// Gets or sets a delegate to use for logging
    /// </summary>
    public LogDelegate LogDelegate
    {
      get { return _logDelegate; }
      set { _logDelegate = value; }
    }

    /// <summary>
    /// Gets or sets an OpenGL context that RetroGL cores can render to
    /// </summary>
    public IRetroGLContext GLContext
    {
      get { return _glContext; }
      set { _glContext = value; }
    }

    /// <summary>
    /// Gets or sets a controller interface to use for polling for input events
    /// </summary>
    public IRetroController Controller
    {
      get { return _retroController; }
      set
      {
        _retroController = value;
        _retroPad = value as IRetroPad;
        _retroAnalog = value as IRetroAnalog;
        _retroKeyboard = value as IRetroKeyboard;
        _retroPointer = value as IRetroPointer;
        _retroRumble = value as IRetroRumble;
      }
    }

    /// <summary>
    /// Gets or sets the system directory to pass to the LibRetro core
    /// </summary>
    public string SystemDirectory
    {
      get { return _systemDirectory; }
      set { _systemDirectory = value; }
    }

    /// <summary>
    /// Gets or sets the save directory to provide to the LibRetro core
    /// </summary>
    public string SaveDirectory
    {
      get { return _saveDirectory; }
      set { _saveDirectory = value; }
    }

    /// <summary>
    /// Gets the system information provided by the LibRetro core
    /// </summary>
    public SystemInfo SystemInfo
    {
      get { return _systemInfo; }
    }

    /// <summary>
    /// Gets the available variables defined by the LibRetro core and allows variables to be set
    /// </summary>
    public LibRetroVariables Variables
    {
      get { return _variables; }
    }

    /// <summary>
    /// Gets information about the video output of the LibRetro core.
    /// Potentially updated every time the video buffer/OpenGL context is updated
    /// </summary>
    public VideoInfo VideoInfo
    {
      get { return _videoInfo; }
    }

    /// <summary>
    /// Gets the timing information provided by the LibRetro core
    /// </summary>
    public TimingInfo TimingInfo
    {
      get { return _timingInfo; }
    }

    /// <summary>
    /// Gets the pixel data of the last video frame generated by the LibRetro core.
    /// Not used for RetroGL cores, they directly render to an OpenGL frame buffer provided by the <see cref="GLContext"/>
    /// </summary>
    public int[] VideoBuffer
    {
      get { return _videoBuffer; }
    }

    /// <summary>
    /// Gets the audio data of the last audio frame generated by the LibRetro core.
    /// </summary>
    public AudioBuffer AudioBuffer
    {
      get { return _audioBuffer; }
    }

    /// <summary>
    /// Gets or sets a value indicating whether the frontend can duplicate video frames 
    /// </summary>
    public bool CanDupeFrame
    {
      get { return _canDupe; }
      set { _canDupe = value; }
    }

    /// <summary>
    /// Gets the suggested performance level of the frontend.
    /// Values range from 1 - 15, where 1 is low performance and 15 high performance.
    /// </summary>
    public uint PerformanceLevel
    {
      get { return _performanceLevel; }
    }
    #endregion

    #region Events
    /// <summary>
    /// Fired when the <see cref="VideoBuffer"/> has been updated
    /// </summary>
    public event EventHandler VideoReady;
    protected virtual void OnVideoReady()
    {
      var handler = VideoReady;
      if (handler != null)
        handler(this, EventArgs.Empty);
    }

    /// <summary>
    /// Fired when the FrameBuffer provided by the <see cref="GLContext"/> has been updated
    /// </summary>
    public event EventHandler FrameBufferReady;
    protected virtual void OnFrameBufferReady()
    {
      var handler = FrameBufferReady;
      if (handler != null)
        handler(this, EventArgs.Empty);
    }

    /// <summary>
    /// Fired when the <see cref="AudioBuffer"/> has been updated
    /// </summary>
    public event EventHandler AudioReady;
    protected virtual void OnAudioReady()
    {
      var handler = AudioReady;
      if (handler != null)
        handler(this, EventArgs.Empty);
    }
    #endregion

    #region Ctor
    /// <summary>
    /// 
    /// </summary>
    /// <param name="corePath">The path to the LibRetro core to load</param>
    public LibRetroEmulator(string corePath)
    {
      _corePath = corePath;
      InitCallbacks();
    }
    #endregion

    #region Init/Deinit
    /// <summary>
    /// Initializes the LibRetro core
    /// </summary>
    public void Init()
    {
      _retro = new LibRetroCore(_corePath);
      try
      {        
        InitPaths();
        SetCallbacks();
        _retro.retro_init();
        UpdateSystemInfo();
      }
      catch
      {
        _retro.Dispose();
        _retro = null;
        throw;
      }
    }

    /// <summary>
    /// Deinitialize the LibRetro core
    /// </summary>
    public void DeInit()
    {
      //Mupen64 crashes if deinit is called when run hasn't been called
      if (!_firstRun)
        _retro.retro_deinit();
    }

    protected void InitCallbacks()
    {
      retro_environment_cb = new LibRetroCore.retro_environment_t(retro_environment);
      retro_video_refresh_cb = new LibRetroCore.retro_video_refresh_t(retro_video_refresh);
      retro_audio_sample_cb = new LibRetroCore.retro_audio_sample_t(retro_audio_sample);
      retro_audio_sample_batch_cb = new LibRetroCore.retro_audio_sample_batch_t(retro_audio_sample_batch);
      retro_input_poll_cb = new LibRetroCore.retro_input_poll_t(retro_input_poll);
      retro_input_state_cb = new LibRetroCore.retro_input_state_t(retro_input_state);
      retro_log_printf_cb = new LibRetroCore.retro_log_printf_t(retro_log_printf);
      retro_rumble_interface.set_rumble_state = new LibRetroCore.retro_set_rumble_state_t(retro_set_rumble_state);

      //no way (need new mechanism) to check for SSSE3, MMXEXT, SSE4, SSE42
      retro_perf_callback.get_cpu_features = new LibRetroCore.retro_get_cpu_features_t(() => (ulong)(
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsXMMIAvailable) ? LibRetroCore.RETRO_SIMD.SSE : 0) |
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsXMMI64Available) ? LibRetroCore.RETRO_SIMD.SSE2 : 0) |
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsSSE3Available) ? LibRetroCore.RETRO_SIMD.SSE3 : 0) |
          (Win32PInvokes.IsProcessorFeaturePresent(Win32PInvokes.ProcessorFeature.InstructionsMMXAvailable) ? LibRetroCore.RETRO_SIMD.MMX : 0)
        ));
      retro_perf_callback.get_perf_counter = new LibRetroCore.retro_perf_get_counter_t(() => System.Diagnostics.Stopwatch.GetTimestamp());
      retro_perf_callback.get_time_usec = new LibRetroCore.retro_perf_get_time_usec_t(() => DateTime.Now.Ticks / 10);
      retro_perf_callback.perf_log = new LibRetroCore.retro_perf_log_t(() => { });
      retro_perf_callback.perf_register = new LibRetroCore.retro_perf_register_t((ref LibRetroCore.retro_perf_counter counter) => { });
      retro_perf_callback.perf_start = new LibRetroCore.retro_perf_start_t((ref LibRetroCore.retro_perf_counter counter) => { });
      retro_perf_callback.perf_stop = new LibRetroCore.retro_perf_stop_t((ref LibRetroCore.retro_perf_counter counter) => { });
    }

    protected void SetCallbacks()
    {
      _retro.retro_set_environment(retro_environment_cb);
      _retro.retro_set_video_refresh(retro_video_refresh_cb);
      _retro.retro_set_audio_sample(retro_audio_sample_cb);
      _retro.retro_set_audio_sample_batch(retro_audio_sample_batch_cb);
      _retro.retro_set_input_poll(retro_input_poll_cb);
      _retro.retro_set_input_state(retro_input_state_cb);
    }

    protected void InitPaths()
    {
      if (string.IsNullOrEmpty(_systemDirectory))
        _systemDirectory = Path.GetDirectoryName(_corePath);
      if (string.IsNullOrEmpty(_saveDirectory))
        _saveDirectory = Path.GetDirectoryName(_corePath);
    }

    protected void UpdateSystemInfo()
    {
      LibRetroCore.retro_system_info system_info = new LibRetroCore.retro_system_info();
      _retro.retro_get_system_info(ref system_info);
      _systemInfo = new SystemInfo()
      {
        LibraryName = Marshal.PtrToStringAnsi(system_info.library_name),
        LibraryVersion = Marshal.PtrToStringAnsi(system_info.library_version),
        ValidExtensions = Marshal.PtrToStringAnsi(system_info.valid_extensions),
        NeedsFullPath = system_info.need_fullpath,
        BlockExtract = system_info.block_extract
      };
    }
    #endregion

    #region Load Game
    /// <summary>
    /// Loads the specified game.
    /// </summary>
    /// <param name="path">The path to the game to load</param>
    /// <param name="data">If <see cref="SystemInfo.NeedsFullPath"/> is <c>false</c> this should be a byte array containing the game. Otherwise <c>null</c></param>
    /// <returns>True if the game was loaded successfully</returns>
    public bool LoadGame(string path, byte[] data)
    {
      return LoadGame(path, data, "");
    }

    /// <summary>
    /// Loads the specified game.
    /// </summary>
    /// <param name="path">The path to the game to load</param>
    /// <param name="data">If <see cref="SystemInfo.NeedsFullPath"/> is <c>false</c> this should be a byte array containing the game. Otherwise <c>null</c></param>
    /// <param name="meta">The metadata to pass to the core</param>
    /// <returns>True if the game was loaded successfully</returns>
    public bool LoadGame(string path, byte[] data, string meta)
    {
      LibRetroCore.retro_game_info gameInfo = new LibRetroCore.retro_game_info();
      gameInfo.path = path;
      gameInfo.meta = meta;
      if (data == null || data.Length == 0)
        return LoadGame(gameInfo);

      fixed (byte* p = &data[0])
      {
        gameInfo.data = (IntPtr)p;
        gameInfo.size = (uint)data.Length;
        return LoadGame(gameInfo);
      }
    }

    /// <summary>
    /// Loads the specified game.
    /// </summary>
    /// <param name="gameInfo">The game to load</param>
    /// <returns>True if the game was loaded successfully</returns>
    public bool LoadGame(LibRetroCore.retro_game_info gameInfo)
    {
      if (!_retro.retro_load_game(ref gameInfo))
      {
        Log(LibRetroCore.RETRO_LOG_LEVEL.WARN, "retro_load_game() failed");
        return false;
      }
      SetAVInfo();
      return true;
    }

    /// <summary>
    /// 
    /// </summary>
    public void Reset()
    {
      _retro.retro_reset();
    }

    /// <summary>
    /// Unloads the currently loaded game
    /// </summary>
    public void UnloadGame()
    {
      _retro.retro_unload_game();
    }

    protected void SetAVInfo()
    {
      LibRetroCore.retro_system_av_info av = new LibRetroCore.retro_system_av_info();
      _retro.retro_get_system_av_info(ref av);
      _maxVideoWidth = (int)av.geometry.max_width;
      _maxVideoHeight = (int)av.geometry.max_height;
      _videoBuffer = new int[_maxVideoWidth * _maxVideoHeight];
      _audioBuffer = new AudioBuffer();
      _audioBuffer.Data = new short[2];
      _videoInfo = new VideoInfo((int)av.geometry.base_width, (int)av.geometry.base_height, av.geometry.aspect_ratio);
      _timingInfo = new TimingInfo(av.timing.fps, av.timing.sample_rate);
    }
    #endregion

    #region Run
    /// <summary>
    /// Advances the currently loaded game by 1 frame
    /// </summary>
    public void Run()
    {
      CheckGLContextStatus();
      _retro.retro_run();
    }

    protected void CheckGLContextStatus()
    {
      if (!_firstRun)
        return;
      _firstRun = false;
      if (_glContext != null)
        _glContext.Create(_maxVideoWidth, _maxVideoHeight);
    }
    #endregion

    #region Memory
    /// <summary>
    /// Returns the size of the specified memory type
    /// </summary>
    /// <param name="memoryType">The type of memory</param>
    /// <returns>The size of the memory type</returns>
    public int GetMemorySize(LibRetroCore.RETRO_MEMORY memoryType)
    {
      return (int)_retro.retro_get_memory_size(memoryType);
    }

    /// <summary>
    /// Writes the specified memory data to the provided buffer
    /// </summary>
    /// <param name="memoryType">The type of memory</param>
    /// <param name="buffer">A buffer to write the memory to. This should be at least the size returned by <see cref="GetMemorySize(LibRetroCore.RETRO_MEMORY)"/></param>
    /// <returns>True if the memory data was successfully retrieved</returns>
    public bool GetMemoryData(LibRetroCore.RETRO_MEMORY memoryType, byte[] buffer)
    {
      int size = (int)_retro.retro_get_memory_size(memoryType);
      if (size == 0)
        return false;
      IntPtr ptr = _retro.retro_get_memory_data(memoryType);
      if (ptr == IntPtr.Zero)
        return false;
      Marshal.Copy(ptr, buffer, 0, size);
      return true;
    }

    /// <summary>
    /// Convenience method for <see cref="GetMemoryData(LibRetroCore.RETRO_MEMORY, byte[])"/> that allocates and returns a buffer containing the memory data
    /// </summary>
    /// <param name="memoryType">The type of memory to retrieve</param>
    /// <returns>A byte array containing the memory data</returns>
    public byte[] GetMemoryData(LibRetroCore.RETRO_MEMORY memoryType)
    {
      uint size = _retro.retro_get_memory_size(memoryType);
      if (size == 0)
        return null;
      IntPtr ptr = _retro.retro_get_memory_data(memoryType);
      if (ptr == IntPtr.Zero)
        return null;
      byte[] saveBuffer = new byte[size];
      Marshal.Copy(ptr, saveBuffer, 0, saveBuffer.Length);
      return saveBuffer;
    }

    /// <summary>
    /// Loads memory data of the specified type into the LibRetro core
    /// </summary>
    /// <param name="memoryType">The type of memory to load</param>
    /// <param name="buffer">A byte array containing the memory data</param>
    /// <returns>True if the memory data was successfully loaded</returns>
    public bool SetMemoryData(LibRetroCore.RETRO_MEMORY memoryType, byte[] buffer)
    {
      int size = GetMemorySize(memoryType);
      if (size > buffer.Length)
        size = buffer.Length;
      IntPtr ptr = _retro.retro_get_memory_data(memoryType);
      if (ptr == IntPtr.Zero)
        return false;
      Marshal.Copy(buffer, 0, ptr, size);
      return true;
    }

    /// <summary>
    /// Gets the size of the serialized state
    /// </summary>
    /// <returns>The size of the serialized state</returns>
    public int GetSerializeSize()
    {
      return (int)_retro.retro_serialize_size();
    }

    /// <summary>
    /// Serializes the current state of the LibRetro core to the provided buffer
    /// </summary>
    /// <param name="buffer">The buffer to write the serialized state to. This should be at least the size returned by <see cref="GetSerializeSize"/></param>
    /// <returns>True if the state was successfully serialized</returns>
    public bool Serialize(byte[] buffer)
    {
      uint size = _retro.retro_serialize_size();
      if (size == 0)
        return false;
      fixed (byte* p = &buffer[0])
        return _retro.retro_serialize((IntPtr)p, size);
    }

    /// <summary>
    /// Convenience method for <see cref="Serialize(byte[])"/> that allocates and returns a buffer containing the serialized state
    /// </summary>
    /// <returns>A buffer containing the current state of the LibRetro core if successful, otherwise null</returns>
    public byte[] Serialize()
    {
      uint size = _retro.retro_serialize_size();
      byte[] buffer = new byte[size];
      bool result;
      fixed (byte* p = &buffer[0])
        result = _retro.retro_serialize((IntPtr)p, size);
      return result ? buffer : null;
    }

    /// <summary>
    /// Unserializes a serialized state into the LibRetro core
    /// </summary>
    /// <param name="buffer">A buffer containing the serialized state</param>
    public void Unserialize(byte[] buffer)
    {
      uint size = _retro.retro_serialize_size();
      fixed (byte* p = &buffer[0])
        _retro.retro_unserialize((IntPtr)p, size);
    }
    #endregion

    #region Environment
    protected bool retro_environment(LibRetroCore.RETRO_ENVIRONMENT cmd, IntPtr data)
    {
      //Log("Environment: {0}", cmd);
      switch (cmd)
      {
        case LibRetroCore.RETRO_ENVIRONMENT.SET_ROTATION:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_OVERSCAN:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_CAN_DUPE:
          *(bool*)data.ToPointer() = _canDupe;
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_MESSAGE:
          return SetMessage(data);
        case LibRetroCore.RETRO_ENVIRONMENT.SHUTDOWN:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_PERFORMANCE_LEVEL:
          _performanceLevel = *(uint*)data.ToPointer();
          Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "Core suggested SET_PERFORMANCE_LEVEL {0}", _performanceLevel);
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_SYSTEM_DIRECTORY:
          Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "returning system directory: " + _systemDirectory);
          return SetDirectory(data, _systemDirectory);
        case LibRetroCore.RETRO_ENVIRONMENT.SET_PIXEL_FORMAT:
          return SetPixelFormat(data);
        case LibRetroCore.RETRO_ENVIRONMENT.SET_INPUT_DESCRIPTORS:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_KEYBOARD_CALLBACK:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_DISK_CONTROL_INTERFACE:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_HW_RENDER:
          return InitGlContext(data);
        case LibRetroCore.RETRO_ENVIRONMENT.GET_VARIABLE:
          return GetVariable(data);
        case LibRetroCore.RETRO_ENVIRONMENT.SET_VARIABLES:
          return SetVariables(data);
        case LibRetroCore.RETRO_ENVIRONMENT.GET_VARIABLE_UPDATE:
          return _variables.Updated;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_SUPPORT_NO_GAME:
          _supportsNoGame = true;
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_LIBRETRO_PATH:
          Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "returning libretro path: " + _corePath);
          *((IntPtr*)data.ToPointer()) = _unmanagedResources.StringToHGlobalAnsiCached(_corePath);
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_AUDIO_CALLBACK:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_FRAME_TIME_CALLBACK:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_RUMBLE_INTERFACE:
          Marshal.StructureToPtr(retro_rumble_interface, data, false);
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_INPUT_DEVICE_CAPABILITIES:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_LOG_INTERFACE:
          *(IntPtr*)data = Marshal.GetFunctionPointerForDelegate(retro_log_printf_cb);
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_PERF_INTERFACE:
          Marshal.StructureToPtr(retro_perf_callback, data, false);
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_LOCATION_INTERFACE:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_CORE_ASSETS_DIRECTORY:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.GET_SAVE_DIRECTORY:
          Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "returning save directory: " + _saveDirectory);
          return SetDirectory(data, _saveDirectory);
        case LibRetroCore.RETRO_ENVIRONMENT.SET_CONTROLLER_INFO:
          return true;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_MEMORY_MAPS:
          return false;
        case LibRetroCore.RETRO_ENVIRONMENT.SET_GEOMETRY:
          return SetGeometry(data);
        default:
          Log(LibRetroCore.RETRO_LOG_LEVEL.WARN, "Unknkown retro_environment command {0} - {1}", (int)cmd, cmd);
          return false;
      }
    }

    protected bool SetMessage(IntPtr data)
    {
      LibRetroCore.retro_message msg = new LibRetroCore.retro_message();
      Marshal.PtrToStructure(data, msg);
      if (!string.IsNullOrEmpty(msg.msg))
        Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "LibRetro Message: {0}", msg.msg);
      return true;
    }

    protected bool SetDirectory(IntPtr data, string directory)
    {
      if (!CreateDirectory(directory))
        return false;
      *((IntPtr*)data.ToPointer()) = _unmanagedResources.StringToHGlobalAnsiCached(directory);
      return true;
    }

    protected bool CreateDirectory(string directory)
    {
      try
      {
        Directory.CreateDirectory(directory);
        return true;
      }
      catch (Exception ex)
      {
        Log(LibRetroCore.RETRO_LOG_LEVEL.ERROR, "Error creating directory '{0}' - {1}", directory, ex);
      }
      return false;
    }

    protected bool SetPixelFormat(IntPtr data)
    {
      LibRetroCore.RETRO_PIXEL_FORMAT format = (LibRetroCore.RETRO_PIXEL_FORMAT)Marshal.ReadInt32(data);
      switch (format)
      {
        case LibRetroCore.RETRO_PIXEL_FORMAT.RGB565:
        case LibRetroCore.RETRO_PIXEL_FORMAT.XRGB1555:
        case LibRetroCore.RETRO_PIXEL_FORMAT.XRGB8888:
          _pixelFormat = format;
          Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "New pixel format set: {0}", _pixelFormat);
          return true;
        default:
          Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "Unrecognized pixel format: {0}", (int)format);
          return false;
      }
    }

    protected bool GetVariable(IntPtr data)
    {
      void** variablesPtr = (void**)data.ToPointer();
      IntPtr pKey = new IntPtr(*variablesPtr++);
      string key = Marshal.PtrToStringAnsi(pKey);
      Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "Requesting variable: {0}", key);
      VariableDescription variable;
      if (!_variables.TryGet(key, out variable))
      {
        Log(LibRetroCore.RETRO_LOG_LEVEL.WARN, "Variable {0}: not found", key);
        return false;
      }
      Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "Variable {0}: {1}", key, variable.SelectedOption);
      *variablesPtr = _unmanagedResources.StringToHGlobalAnsiCached(variable.SelectedOption).ToPointer();
      return true;
    }

    protected bool SetVariables(IntPtr data)
    {
      void** variablesPtr = (void**)data.ToPointer();
      for (;;)
      {
        IntPtr pKey = new IntPtr(*variablesPtr++);
        if (pKey == IntPtr.Zero)
          break;
        IntPtr pValue = new IntPtr(*variablesPtr++);
        VariableDescription variable = new VariableDescription(pKey, pValue);
        _variables.AddOrUpdate(variable);
        Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "Set variable: {0}", variable);
      }
      return true;
    }

    protected bool InitGlContext(IntPtr data)
    {
      LibRetroCore.retro_hw_render_callback* info = (LibRetroCore.retro_hw_render_callback*)data.ToPointer();
      Log(LibRetroCore.RETRO_LOG_LEVEL.DEBUG, "SET_HW_RENDER: {0}, version={1}.{2}, dbg/cache={3}/{4}, depth/stencil = {5}/{6}{7}", info->context_type, info->version_minor, info->version_major, info->debug_context, info->cache_context, info->depth, info->stencil, info->bottom_left_origin ? " (bottomleft)" : "");
      if (_glContext == null)
        return false;
      
      info->get_current_framebuffer = Marshal.GetFunctionPointerForDelegate(_glContext.GetCurrentFramebufferDlgt);
      info->get_proc_address = Marshal.GetFunctionPointerForDelegate(_glContext.GetProcAddressDlgt);

      LibRetroCore.retro_hw_context_reset_t contextReset = Marshal.GetDelegateForFunctionPointer<LibRetroCore.retro_hw_context_reset_t>(info->context_reset);
      LibRetroCore.retro_hw_context_reset_t contextDestroy = null;
      if (info->context_destroy != IntPtr.Zero)
        contextDestroy = Marshal.GetDelegateForFunctionPointer<LibRetroCore.retro_hw_context_reset_t>(info->context_destroy);
      _glContext.Init(info->depth, info->stencil, info->bottom_left_origin, contextReset, contextDestroy);
      return true;
    }

    protected bool SetGeometry(IntPtr data)
    {
      LibRetroCore.retro_game_geometry geometry = *((LibRetroCore.retro_game_geometry*)data.ToPointer());
      _videoInfo = new VideoInfo((int)geometry.base_width, (int)geometry.base_height, geometry.aspect_ratio);
      return true;
    }
    #endregion

    #region Video
    protected void retro_video_refresh(IntPtr data, uint width, uint height, uint pitch)
    {
      //dupe frame
      if (data == IntPtr.Zero)
        return;

      int intWidth = (int)width;
      int intHeight = (int)height;
      _videoInfo = new VideoInfo(intWidth, intHeight, _videoInfo.DAR);
      if (data.ToInt32() == LibRetroCore.RETRO_HW_FRAME_BUFFER_VALID)
        OnFrameBufferReady();
      else
        UpdateVideoBuffer(data, intWidth, intHeight, (int)pitch);
    }

    protected void UpdateVideoBuffer(IntPtr data, int width, int height, int pitch)
    {
      if (width * height > _videoBuffer.Length)
        _videoBuffer = new int[width * height];
      fixed (int* dst = &_videoBuffer[0])
        VideoBlitter.Blit(_pixelFormat, data, dst, width, height, pitch);
      OnVideoReady();
    }
    #endregion

    #region Audio
    protected void retro_audio_sample(short left, short right)
    {
      _audioBuffer.Data[0] = left;
      _audioBuffer.Data[1] = right;
      _audioBuffer.Length = 2;
      OnAudioReady();
    }

    protected uint retro_audio_sample_batch(IntPtr data, uint frames)
    {
      int samples = (int)(frames * 2);
      if (_audioBuffer.Data.Length < samples)
        _audioBuffer.Data = new short[samples];
      Marshal.Copy(data, _audioBuffer.Data, 0, samples);
      _audioBuffer.Length = samples;
      OnAudioReady();
      return frames;
    }
    #endregion

    #region Input
    protected void retro_input_poll() { }

    protected short retro_input_state(uint port, uint device, uint index, uint id)
    {
      switch ((LibRetroCore.RETRO_DEVICE)device)
      {
        case LibRetroCore.RETRO_DEVICE.POINTER:
          return GetPointerStatus((LibRetroCore.RETRO_DEVICE_ID_POINTER)id);
        case LibRetroCore.RETRO_DEVICE.KEYBOARD:
          return GetKeyboardStatus((LibRetroCore.RETRO_KEY)id) ? TRUE_SHORT : FALSE_SHORT;
        case LibRetroCore.RETRO_DEVICE.JOYPAD:
          return GetRetroPadStatus(port, (LibRetroCore.RETRO_DEVICE_ID_JOYPAD)id) ? TRUE_SHORT : FALSE_SHORT;
        case LibRetroCore.RETRO_DEVICE.ANALOG:
          return GetAnalogStatus(port, (LibRetroCore.RETRO_DEVICE_INDEX_ANALOG)index, (LibRetroCore.RETRO_DEVICE_ID_ANALOG)id);
      }
      return 0;
    }

    protected bool retro_set_rumble_state(uint port, LibRetroCore.retro_rumble_effect effect, ushort strength)
    {
      return _retroRumble != null ? _retroRumble.SetRumbleState(port, effect, strength) : false;
    }

    protected short GetPointerStatus(LibRetroCore.RETRO_DEVICE_ID_POINTER id)
    {
      if (_retroPointer != null)
      {
        switch (id)
        {
          case LibRetroCore.RETRO_DEVICE_ID_POINTER.X: return _retroPointer.GetPointerX();
          case LibRetroCore.RETRO_DEVICE_ID_POINTER.Y: return _retroPointer.GetPointerY();
          case LibRetroCore.RETRO_DEVICE_ID_POINTER.PRESSED: return _retroPointer.IsPointerPressed() ? TRUE_SHORT : FALSE_SHORT;
        }
      }
      return 0;
    }

    protected bool GetKeyboardStatus(LibRetroCore.RETRO_KEY key)
    {
      return _retroKeyboard != null && _retroKeyboard.IsKeyPressed(key);
    }

    protected bool GetRetroPadStatus(uint port, LibRetroCore.RETRO_DEVICE_ID_JOYPAD button)
    {
      return _retroPad != null && _retroPad.IsButtonPressed(port, button);
    }

    protected short GetAnalogStatus(uint port, LibRetroCore.RETRO_DEVICE_INDEX_ANALOG analogIndex, LibRetroCore.RETRO_DEVICE_ID_ANALOG analogDirection)
    {
      return _retroAnalog != null ? _retroAnalog.GetAnalog(port, analogIndex, analogDirection) : FALSE_SHORT;
    }
    #endregion

    #region Log
    protected void retro_log_printf(LibRetroCore.RETRO_LOG_LEVEL level, string fmt, IntPtr a0, IntPtr a1, IntPtr a2, IntPtr a3, IntPtr a4, IntPtr a5, IntPtr a6, IntPtr a7, IntPtr a8, IntPtr a9, IntPtr a10, IntPtr a11, IntPtr a12, IntPtr a13, IntPtr a14, IntPtr a15)
    {
      if (_logDelegate == null)
        return;
      //avert your eyes, these things were not meant to be seen in c#
      //I'm not sure this is a great idea. It would suck for silly logging to be unstable. But.. I dont think this is unstable. The sprintf might just print some garbledy stuff.
      IntPtr[] args = new IntPtr[] { a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 };
      string message = Printf(fmt, args);
      _logDelegate(level, message);
    }

    protected void Log(LibRetroCore.RETRO_LOG_LEVEL level, string format, params object[] args)
    {
      if (_logDelegate != null)
        _logDelegate(level, string.Format(format, args));
    }

    protected string Printf(string format, IntPtr[] args)
    {
      int idx = 0;
      string message;
      try
      {
        message = Sprintf.sprintf(format, () => args[idx++]);
      }
      catch (Exception ex)
      {
        message = string.Format("Error in sprintf - {0}", ex);
      }
      return message;
    }
    #endregion

    #region IDisposable
    /// <summary>
    /// Disposes the LibRetro core, the OpenGL context and any unmanaged resources
    /// </summary>
    public void Dispose()
    {
      if (_retro != null)
      {        
        _retro.Dispose();
        _retro = null;
      }
      if (_glContext != null)
      {
        _glContext.Dispose();
        _glContext = null;
      }
      _unmanagedResources.Dispose();
    }
    #endregion
  }
}